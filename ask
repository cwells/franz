#!/bin/env python3

from __future__ import absolute_import, print_function

import re
import operator as op
import click
from functools import partial
from decorator import decorator
from greenlet import greenlet
from pprint import pprint
from copy import copy
from lark import Lark, Tree, InlineTransformer
from lark.lexer import Token

try:
    input = raw_input
except NameError:
    pass

GRAMMAR = 'grammars/ask.g'
EXTENSION = '.ask'

typedecl = {
    'int':   int,
    'float': float,
    'str':   str,
    'list':  list,
    'dict':  dict,
    'bool':  bool,
    'any':   lambda v: v
}

class ReturnException(Exception):
    def __init__(self, value):
        self.value = value

class InvalidArgument(Exception): pass
class InvalidToken(Exception): pass

class Atomize(InlineTransformer):
    integer = int
    decimal = float
    string  = lambda _, v: str(v[1:-1] if v[0] == v[-1] == '"' else v)
    true    = lambda _: True
    false   = lambda _: False

    def signature(self, *args):
        sig = []
        iargs = iter(args)
        for param in iargs:
            paramtype = next(iargs)
            if isinstance(param, Tree): param = param.children[0].value
            elif isinstance(param, Token): param = param.value
            sig.append((param, typedecl.get(paramtype, None)))
        return sig


parser = Lark(
    open(GRAMMAR).read(),
    start       = 'program',
    parser      = 'lalr',
    transformer = Atomize()
)

class Function(object):
    def __init__(self, signature, code):
        self.signature = signature
        self.code = code
        self.yield_to = None
        self.interpreter = None

    def __call__(self, context, name, *args, **kwargs):
        ctx = {}
        ctx.update(context)
        ctx.update(kwargs)
        self.interpreter = Interpreter(context=ctx)
        self.interpreter.yield_expr = self.yield_expr # monkey-patch interpreter
        return self.interpreter.eval(self.code) if isinstance(self.code, Tree) else self.code.value

    def yield_expr(self, ast):
        item = self.interpreter.eval(ast)
        self.yield_to.switch(item) # jump to call method
        return item


class LenFunction(Function):
    def __call__(self, context, name, *args, **kwargs):
        return len(kwargs['var'])


class PrintFunction(Function):
    def __call__(self, context, name, *args, **kwargs):
        msg = str(kwargs['msg']).format(**context).replace('\\n', '\n')
        print(msg.format(context), end='')
        return msg


class Interpreter(object):
    def __init__(self, context=None):
        self.context = context if context else {}

    #
    # eval
    #
    def eval(self, ast):
        if isinstance(ast, list):
            retval = [ self.eval(b) for b in ast ]
            return retval[-1]

        if not hasattr(ast, 'data'):
            return ast

        if hasattr(self, ast.data):
            return getattr(self, ast.data)(ast.children)

        raise InvalidToken

    #
    # builtin functions
    #
    fn_print = PrintFunction(signature = [ ('msg', typedecl['str']) ], code = print)
    fn_len   = LenFunction(signature   = [ ('var', typedecl['any']) ], code = len)

    #
    # token actions (alphabetical)
    #
    def add(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a + b

    def args(self, ast):
        pargs = []
        nargs = {}
        for arg in ast:
            if isinstance(arg, Tree) and arg.data == 'assoc':
                nargs.update(self.eval(arg))
            else:
                pargs.append(self.eval(arg) if isinstance(arg, Tree) else arg)

        return pargs, nargs

    def array(self, ast):
        retval = []
        for branch in ast:
            if isinstance(branch, Tree): branch = self.eval(branch)
            retval.extend(branch)
        return retval

    def arrayitem(self, ast):
        return [ self.eval(b) if isinstance(b, Tree) else b for b in ast ]

    def assertion(self, ast):
        condition = self.eval(ast[0])
        assert condition
        return condition

    def assign(self, ast):
        var, val = ast
        self.context[var.value] = self.eval(val)
        return self.context[var.value]

    def assign_add(self, ast):
        var, val = ast
        if isinstance(val, Tree): val = self.eval(val)
        self.context[var] += val
        return self.context[var]

    def assign_div(self, ast):
        var, val = ast
        if isinstance(val, Tree): val = self.eval(val)
        self.context[var] /= val
        return self.context[var]

    def assign_mul(self, ast):
        var, val = ast
        if isinstance(val, Tree): val = self.eval(val)
        self.context[var] *= val
        return self.context[var]

    def assign_sub(self, ast):
        var, val = ast
        if isinstance(val, Tree): val = self.eval(val)
        self.context[var] -= val
        return self.context[var]

    def assoc(self, ast):
        retval = {}
        branch = iter(ast)
        for key in branch:
            val = next(branch)
            if isinstance(val, Tree): val = self.eval(val)
            retval[key.value if hasattr(key, 'value') else key] = val
        return retval

    def block(self, ast):
        retval = None
        for branch in ast:
            retval = self.eval(branch)
        return retval

    def call(self, ast):
        def validate(signature, pargs, nargs):
            sig = copy(signature)
            retval = {}

            for value in pargs:
                try:
                    name, valid = sig.pop(0)
                except (IndexError, KeyError):
                    raise InvalidArgument
                retval[name] = valid(value)

            sig = dict(sig)
            for name, value in nargs.items():
                try:
                    valid = sig[name]
                except KeyError:
                    raise InvalidArgument
                retval[name] = valid(value)

            return retval

        name, args = str(ast[0]), ast[1:]
        pargs = [] # positional args
        nargs = {} # named args
        aargs = [ self.eval(a) if isinstance(a, Tree) else a for a in args ]
        try:
            pargs, nargs = aargs[0]
        except IndexError:
            pass
        fn = self.context[name] if name in self.context else getattr(self, 'fn_' + name)
        args = validate(fn.signature, pargs=pargs, nargs=nargs)

        yield_val = []
        def switch_handler(item):
            while True:
                yield_val.append(item)
                item = fn_greenlet.switch()
            return yield_val

        def catch_return(fn, context, name, **kwargs):
            try:
                return fn(context=context, name=name, **kwargs)
            except ReturnException as e:
                return e.value

        fn.yield_to = greenlet(switch_handler)
        fn_greenlet = greenlet(partial(catch_return, fn, self.context, name=name, **args))
        retval = fn_greenlet.switch()

        return yield_val if yield_val else retval

    def cmp_eq(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a == b

    def cmp_gt(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a > b

    def cmp_gteq(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a >= b

    def cmp_log(self, ast):
        bools = { 'or': op.or_, 'and': op.and_ }
        ast = copy(ast)
        branch = ast.pop(0)
        retval = self.eval(branch) if isinstance(branch, Tree) else branch
        while ast:
            logop, val = ast.pop(0), ast.pop(0)
            val = self.eval(val) if isinstance(val, Tree) else val
            retval = bools[logop.value](retval, val)
        return retval

    def cmp_lt(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a < b

    def cmp_lteq(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a <= b

    def cmp_neq(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a != b

    def div(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a / b

    def expr(self, ast):
        return self.eval(ast[0])

    def floor(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a // b

    def forloop(self, ast):
        var, irange, block = ast
        var = var.value
        irange = self.eval(irange)
        retval = None

        for self.context[var] in irange:
            retval = self.eval(block)
        return retval

    def funcdef(self, ast):
        try:
            signature, block = ast
        except ValueError:
            block = ast[0]
            signature = {}
        return Function(signature, block)

    def ifcond(self, ast):
        if self.eval(ast[0]):
            return self.eval(ast[1])
        elif len(ast) > 2:
            return self.eval(ast[2])

    def include_file(self, ast):
        filename = ast[0]
        ast = parser.parse(open(filename + EXTENSION, 'r').read())
        return self.eval(ast)

    def irange(self, ast):
        try:
            start, end = ast
            step = 1
        except ValueError:
            start, end, step = ast

        if isinstance(start, Tree): start = self.eval(start)
        if isinstance(end, Tree): end = self.eval(end)
        if isinstance(step, Tree): step = self.eval(step)

        return range(start, end + 1, step)

    def mod(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a % b

    def mul(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a * b

    def name(self, ast):
        return self.context[ast[0].value]

    def nil(self, ast):
        return None

    def postdec(self, ast):
        var = ast[0]
        retval = self.context[var]
        self.context[var] -= 1
        return retval

    def postinc(self, ast):
        var = ast[0]
        retval = self.context[var]
        self.context[var] += 1
        return retval

    def predec(self, ast):
        var = ast[0]
        self.context[var] -= 1
        return self.context[var]

    def preinc(self, ast):
        var = ast[0]
        self.context[var] += 1
        return self.context[var]

    def pow(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a ** b

    def program(self, ast):
        retval = None
        for branch in ast:
            retval = self.eval(branch)
        return retval

    def regex(self, ast):
        '''not implemented
        '''
        print(ast)
        raise SystemExit

    def return_expr(self, ast):
        retval = ast[0] if ast else None
        if isinstance(retval, Tree): retval = self.eval(retval)
        raise ReturnException(retval)

    def sub(self, ast):
        a, b = ast
        if isinstance(a, Tree): a = self.eval(a)
        if isinstance(b, Tree): b = self.eval(b)
        return a - b

    def tryrescue(self, ast):
        try:
            retval = self.eval(ast[0])
        except:
            retval = self.eval(ast[1])
        else:
            if len(ast) == 3:
                retval = self.eval(ast[2])
        return retval

    def whileloop(self, ast):
        condition, block = ast
        retval = None
        while self.eval(condition):
            retval = self.eval(block)
        return retval

    def yield_expr(self, ast):
        retval = [ self.eval(b) if isinstance(b, Tree) else ast for b in ast ]
        return retval[-1]


@click.command()
@click.argument('program', type=click.Path(exists=True), required=False, default=None)
@click.option('--grammar', '-g', type=click.Path(exists=True), default='grammars/ask.g')
@click.option('--dump-tree', '-d', is_flag=True)
def main(program, grammar, dump_tree):
    interpreter = Interpreter()

    if program is not None:
        ast = parser.parse(open(program).read())
        interpreter.eval(ast)

        if dump_tree: print(ast.pretty())
        raise SystemExit

    # naive repl
    while True:
        try:
            s = input('> ')
        except EOFError:
            break
        if not s:
            continue

        try:
            ast = parser.parse(s)
        except Exception as e:
            print(e)
            continue

        try:
            print(interpreter.eval(ast))
        except Exception as e:
            print(e)
            continue


if __name__ == '__main__':
    main()